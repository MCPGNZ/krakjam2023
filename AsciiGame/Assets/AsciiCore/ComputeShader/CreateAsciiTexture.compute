#pragma kernel PrepareToCreateAsciiTexture

RWTexture2D<float4> _ResultTexture;

Texture2D<float4> _ScreenSpaceTexutre;

struct SymbolDefinition
{
    float left;
    float right;
    float top;
    float bottom;
    float avarage;
};

StructuredBuffer<SymbolDefinition> _SimpleDefinition;
int _TextureSize;

float pow2(float x)
{
    return x * x;
}

float luminance(float4 color)
{
    return 0.299f * color.r + 0.587f * color.g + 0.114f * color.b;
}

float calculateMSE(SymbolDefinition symbolDefinition, SymbolDefinition generatedSymbolDefinition)
{
    float left = pow2(symbolDefinition.left - generatedSymbolDefinition.left);
    float right = pow2(symbolDefinition.right - generatedSymbolDefinition.right);
    float top = pow2(symbolDefinition.top - generatedSymbolDefinition.top);
    float bottom = pow2(symbolDefinition.bottom - generatedSymbolDefinition.bottom);
    float avarage = pow2(symbolDefinition.avarage - generatedSymbolDefinition.avarage);

    return (left + right + top + bottom + avarage) * 0.2f;
}

[numthreads(1, 1, 1)]
void PrepareToCreateAsciiTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x % 2 == 0 && id.y % 2 == 0)
    {
        const int2 leftBottomId = int2(id.x, id.y);
        const int2 rightBottomId = int2(id.x + 1, id.y);
        const int2 leftTopId = int2(id.x, id.y + 1);
        const int2 rightTopId = int2(id.x + 1, id.y + 1);

        float4 leftBottom = _ScreenSpaceTexutre[leftBottomId];
        float4 leftTop = _ScreenSpaceTexutre[leftTopId];
        float4 rightBottom = _ScreenSpaceTexutre[rightBottomId];
        float4 rightTop = _ScreenSpaceTexutre[rightTopId];

        float leftBottomLuminance = luminance(leftBottom);
        float leftTopLuminance = luminance(leftTop);
        float rightBottomLuminance = luminance(rightBottom);
        float rightTopLuminance = luminance(rightTop);

        SymbolDefinition symbolDefinition;

        symbolDefinition.left = (leftTopLuminance + leftBottomLuminance) * 50.0f;
        symbolDefinition.right = (rightTopLuminance + rightBottomLuminance) * 50.0f;
        symbolDefinition.top = (leftTopLuminance + rightTopLuminance) * 50.0f;
        symbolDefinition.bottom = (leftBottomLuminance + rightBottomLuminance) * 50.0f;
        symbolDefinition.avarage = (leftBottomLuminance + rightBottomLuminance + leftTopLuminance + rightTopLuminance) * 25.0f;
        
        int id = 0;
        float minError = calculateMSE(symbolDefinition, _SimpleDefinition[id]);

        for (int i = 0; i < _TextureSize; ++i)
        {
            float currentError = calculateMSE(symbolDefinition, _SimpleDefinition[i]);
            if (minError > currentError)
            {
                minError = currentError;
                id = i;
            }
        }

        _ResultTexture[leftBottomId] = float4(id, leftBottom.xyz);
        _ResultTexture[rightBottomId] = float4(id, rightBottom.xyz);
        _ResultTexture[leftTopId] = float4(id, leftTop.xyz);
        _ResultTexture[rightTopId] = float4(id, rightTop.xyz);
    }
}